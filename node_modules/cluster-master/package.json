{
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "name": "cluster-master",
  "description": "A helper script for managing a cluster of node worker servers",
  "version": "0.1.1",
  "repository": {
    "type": "git",
    "url": "git://github.com/isaacs/cluster-master.git"
  },
  "main": "cluster-master.js",
  "engines": {
    "node": ">=0.7.7"
  },
  "readme": "# cluster-master\n\nA module for taking advantage of the built-in `cluster` module in node\nv0.8 and above.\n\nYour main `server.js` file uses this module to fire up a cluster of\nworkers.  Those workers then do the actual server stuff (using socket.io,\nexpress, tako, raw node, whatever; any TCP/TLS/HTTP/HTTPS server would\nwork.)\n\nThis module provides some basic functionality to keep a server running.\nAs the name implies, it should only be run in the master module, not in\nany cluster workers.\n\n```javascript\nvar clusterMaster = require(\"cluster-master\")\n\n// most basic usage: just specify the worker\n// Spins up as many workers as you have CPUs\n//\n// Note that this is VERY WRONG for a lot of multi-tenanted\n// VPS environments where you may have 32 CPUs but only a\n// 256MB RSS cap or something.\nclusterMaster(\"worker.js\")\n\n// more advanced usage.  Specify configs.\n// in real life, you can only actually call clusterMaster() once.\nclusterMaster({ exec: \"worker.js\" // script to run\n              , size: 5 // number of workers\n              , env: { SOME: \"environment_vars\" }\n              , args: [ \"--deep\", \"doop\" ]\n              , silent: true\n              , signals: false\n              , onMessage: function (msg) {\n                  console.error(\"Message from %s %j\"\n                               , this.uniqueID\n                               , msg)\n                }\n              })\n\n// methods\nclusterMaster.resize(10)\n\n// graceful rolling restart\nclusterMaster.restart()\n\n// graceful shutdown\nclusterMaster.quit()\n\n// not so graceful shutdown\nclusterMaster.quitHard()\n```\n\n## Methods\n\n### clusterMaster.resize(n)\n\nSet the cluster size to `n`.  This will disconnect extra nodes and/or\nspin up new nodes, as needed.  Done by default on restarts.\n\n### clusterMaster.restart(cb)\n\nOne by one, shut down nodes and spin up new ones.  Callback is called\nwhen finished.\n\n### clusterMaster.quit()\n\nGracefully shut down the worker nodes and then process.exit(0).\n\n### clusterMaster.quitHard()\n\nForcibly shut down the worker nodes and then process.exit(1).\n\n## Configs\n\nThe `exec`, `env`, `argv`, and `silent` configs are passed to the\n`cluster.fork()` call directly, and have the same meaning.\n\n* `exec` - The worker script to run\n* `env` - Envs to provide to workers\n* `argv` - Additional args to pass to workers.\n* `silent` - Boolean, default=false.  Do not share stdout/stderr\n* `size` - Starting cluster size.  Default = CPU count\n* `signals` - Boolean, default=true.  Set up listeners to:\n  * `SIGHUP` - restart\n  * `SIGINT` - quit\n  * `SIGKILL` - quitHard\n* `onMessage` - Method that gets called when workers send a message to\n  the parent.  Called in the context of the worker, so you can reply by\n  looking at `this`.\n\n",
  "readmeFilename": "README.md",
  "_id": "cluster-master@0.1.1",
  "_from": "cluster-master@~0.1.0"
}
